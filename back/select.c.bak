

/***********************************
*
*readme
*用于读取信息
*需要输入ip，端口，listen的连接数
*功能：测试select
*
***********************************/
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main(int argc, char *argv[])
{
	
	if (argc < 4)
	{
		printf("usge:%s ip_address port_number backlog\n",
				basename(argv[0]));
		return -1;
	}
	const char *ip = argv[1];							// 读取绑定ip				
	int port = atoi(argv[2]);							// 将端口的ascii转成int
	int backlog = atoi(argv[3]);						// 将监听链接数量的ascii转成int
	
	
	int sock = socket (AF_INET, SOCK_STREAM, 0);		// 创建TCP的socket
	// 如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。
	assert( sock >= 0);
	
	/*创建一个IPv4 socket地址*/
	struct sockaddr_in address;
	bzero(&address, sizeof(address));					// 结构体清零
	address.sin_family = AF_INET;						// TCP/IPv4协议族
	inet_pton(AF_INET, ip, &address.sin_addr);			// 将ip转成网络字节序存入sin_addr
	address.sin_port = htons(port);						// 将端口转成网络字节存入sin_port
			
	int ret = bind (sock, (struct sockaddr*)&address, 	// 绑定socket
					sizeof(address));
	assert (ret != -1);									// 绑定失败则退出
	
	ret = listen(sock, backlog);						// 最多监听backlog个连接
	assert (ret != -1);									// 监听失败则退出
	
	
	struct sockaddr_in client;							// client信息结构体
	socklen_t client_addrlength = sizeof(client);		// socket地址长度
	/*接收socket*/
	int connfd = accept(sock, (struct sockaddr*)&client, &client_addrlength);
	if(connfd < 0)
	{
		printf("errno is:%d\n",errno);
	}
	
	/*开始设置select*/
	char buf[1024];
	fd_set read_fds;									// 可读文件描述符集合
	fd_set exception_fds;								// 异常文件描述符集合
	FD_ZERO( &read_fds);								// 清空可读文件描述符集合
	FD_ZERO( &exception_fds);							// 清空异常文件描述符集合
	
	while(1)
	{
		
		memset( buf, '\0', sizeof( buf ));				// 清空缓存区
		/*每次调用select前都要重新在read_fds，exception_fds
		  中设置文件描述符connfd，因为事件发生后，文件描述
		  集合将被内核修改*/
		FD_SET( connfd, &read_fds );					// 将cnnfd位置1
		FD_SET( connfd, &exception_fds );				// 将cnnfd位置1
		
		ret = select( connfd + 1, &read_fds, NULL, &exception_fds, NULL);
		if( ret < 0)
		{
			printf("selection failure\n");
			break;
		}
		 /*对于可读事件，采取普通的recv函数读取数据*/
		 if ( FD_ISSET( connfd, &read_fds ))			// connfd读取位置1
		 {
			 ret = recv(connfd, buf, sizeof(buf)-1, 0);
			 if(ret <= 0)
			 {
				 break;
			 }
			 printf("get %d bytes of normal data: %s\n", ret, buf);
	
		 }
		 else if(FD_ISSET( connfd, &exception_fds))		// connfd异常位置1
		 {
			 ret = recv(connfd, buf, sizeof(buf)-1, MSG_OOB);
			 if(ret <= 0)
			 {
				 break;
			 }
			 printf("get %d bytes of normal data: %s\n", ret, buf);
		 }
		
	}
	
	close(connfd);
	close(sock);
	return 0;
}


 
















